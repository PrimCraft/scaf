package cmd

import (
	"context"
	"fmt"
	"os"
	"regexp"
	"time"

	"github.com/goccy/go-yaml"
	"github.com/spf13/cobra"

	"github.com/PrimCraft/scaf/internal/manifest"
	"github.com/PrimCraft/scaf/internal/resolver"
)

var (
	manifestFile string
	outputFile   string
	checkMode    bool
)

var resolveCmd = &cobra.Command{
	Use:   "resolve",
	Short: "Resolve plugin versions and generate lock file",
	Long: `Resolve plugin versions from the manifest file and generate a lock file.

Version constraints (semver):
  "latest"           Latest available version
  "5.4.3"            Exact version
  ">=5.0.0,<6.0.0"   Range constraint
  "~5.4"             Patch-level changes allowed (>=5.4.0, <5.5.0)
  "^5.4"             Minor-level changes allowed (>=5.4.0, <6.0.0)`,
	RunE: runResolve,
}

func init() {
	resolveCmd.Flags().StringVarP(&manifestFile, "manifest", "m", "plugins.yaml", "Path to manifest file")
	resolveCmd.Flags().StringVarP(&outputFile, "output", "o", "plugins.lock.yaml", "Path to output lock file")
	resolveCmd.Flags().BoolVar(&checkMode, "check", false, "Check if lock file is up to date (exit 1 if not)")
}

func runResolve(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Load manifest
	data, err := os.ReadFile(manifestFile)
	if err != nil {
		return fmt.Errorf("reading manifest: %w", err)
	}

	var m manifest.Manifest
	if err := yaml.Unmarshal(data, &m); err != nil {
		return fmt.Errorf("parsing manifest: %w", err)
	}

	// Create registry and lockfile
	registry := resolver.NewRegistry()
	lockfile := manifest.NewLockfile()

	// Resolve Velocity if configured
	if m.Velocity.Version != "" {
		fmt.Fprintf(os.Stderr, "Resolving Velocity (constraint: %s)...\n", m.Velocity.Version)
		result, err := registry.Resolve(ctx, "papermc", resolver.PluginConfig{
			Project: "velocity",
			Version: m.Velocity.Version,
		})
		if err != nil {
			return fmt.Errorf("resolving velocity: %w", err)
		}
		lockfile.Velocity = &manifest.ResolvedComponent{
			Version: result.Version,
			Build:   result.Build,
			URL:     result.URL,
		}
		fmt.Fprintf(os.Stderr, "  -> %s (build %d)\n", result.Version, result.Build)
	}

	// Resolve Paper if configured
	if m.Paper.Version != "" {
		fmt.Fprintf(os.Stderr, "Resolving Paper (constraint: %s)...\n", m.Paper.Version)
		result, err := registry.Resolve(ctx, "papermc", resolver.PluginConfig{
			Project: "paper",
			Version: m.Paper.Version,
		})
		if err != nil {
			return fmt.Errorf("resolving paper: %w", err)
		}
		lockfile.Paper = &manifest.ResolvedComponent{
			Version: result.Version,
			Build:   result.Build,
			URL:     result.URL,
		}
		fmt.Fprintf(os.Stderr, "  -> %s (build %d)\n", result.Version, result.Build)
	}

	// Resolve plugins
	for name, plugin := range m.Plugins {
		source := plugin.Source
		if source == "" {
			source = "hangar"
		}

		fmt.Fprintf(os.Stderr, "Resolving %s from %s (constraint: %s)...\n", name, source, plugin.Version)

		cfg := resolver.PluginConfig{
			Source:       source,
			Project:      plugin.Project,
			Version:      plugin.Version,
			Platform:     plugin.Platform,
			Loader:       plugin.Loader,
			GameVersions: plugin.GameVersions,
			Bucket:       plugin.Bucket,
			Key:          plugin.Key,
			URL:          plugin.URL,
		}

		result, err := registry.Resolve(ctx, source, cfg)
		if err != nil {
			return fmt.Errorf("resolving %s: %w", name, err)
		}

		lockfile.Plugins[name] = &manifest.ResolvedPlugin{
			Source:     result.Source,
			Project:    result.Project,
			Version:    result.Version,
			Platform:   result.Platform,
			Loader:     result.Loader,
			URL:        result.URL,
			S3URI:      result.S3URI,
			SHA256:     result.SHA256,
			SHA512:     result.SHA512,
			ResolvedAt: result.ResolvedAt,
		}
		fmt.Fprintf(os.Stderr, "  -> %s\n", result.Version)
	}

	// Generate output
	output, err := yaml.Marshal(lockfile)
	if err != nil {
		return fmt.Errorf("marshaling lockfile: %w", err)
	}

	content := "# Auto-generated lock file - do not edit manually\n"
	content += "# Generated by scaf\n\n"
	content += string(output)

	// Check mode: compare with existing
	if checkMode {
		existing, err := os.ReadFile(outputFile)
		if err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("reading existing lock file: %w", err)
		}

		if normalize(string(existing)) != normalize(content) {
			fmt.Fprintln(os.Stderr, "\nLock file would change. Run without --check to update.")
			os.Exit(1)
		}
		fmt.Fprintln(os.Stderr, "\nLock file is up to date.")
		return nil
	}

	// Write output
	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing lock file: %w", err)
	}

	fmt.Fprintf(os.Stderr, "\nWrote %s\n", outputFile)
	return nil
}

// normalize removes timestamps for comparison
func normalize(content string) string {
	re := regexp.MustCompile(`resolved_at: .*`)
	return re.ReplaceAllString(content, "resolved_at: <timestamp>")
}
